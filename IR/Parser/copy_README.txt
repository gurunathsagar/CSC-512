Danny Reinheimer 
ReadME file

Compile Instructions:
To compiler the parser run the following java command 
javac Parser.java

to execute the parser run the following command in the terminal:
java Parser <inputFileName>

An example of the parser execution is:
java Parser foo.c

The output will be either pass or fail or a scanner error.  If pass the output will also include the number of variables, functions, and statements 

The parser uses recursive decent.  Each rule is implmented as a function whitch returns a boolean value.  I use a vector to store the tokens generated by the scanner.  I check if tokens match the rule and if so pop the token from the top.  At the end of the program I check to see if the last token is the End of File token if so then I know this is valid grammar.



My grammar: production rules = 95, distinct non terminals = 44

<program> --> <type name> ID <data decls> <func list> | empty
<func list> --> empty | left_parenthesis <parameter list> right_parenthesis <func Z> <func list Z> 
<func Z> --> semicolon | left_brace <data decls Z> <statements> right_brace 
<func list Z> --> empty | <type name> ID left_parenthesis <parameter list> right_parenthesis <func Z> <func list Z>
<type name> --> int | void | binary | decimal 
<parameter list> --> empty | void <parameter list Z> | <non-empty list> 
<parameter list Z> --> empty | ID <non-empty list prime>
<non-empty list> --> int ID <non-empty list prime> | binary ID <non-empty list prime> | decimal ID <non-empty list prime> 
<non-empty list prime> --> comma <type name> ID <non-empty list prime> | empty
<data decls> --> empty | <id list Z> semicolon <program> | <id list prime> semicolon <program>
<data decls Z> --> empty | int <id list> semicolon <data decls Z> | void <id list> semicolon <data decls Z> | binary <id list> semicolon <data decls Z> | decimal <id list> semicolon <data decls Z> 
<id list> --> <id> <id list prime>
<id list Z> --> left_bracket <expression> right_bracket <id list prime>
<id list prime> --> comma <id> <id list prime> | empty
<id> --> ID <id Z>
<id Z> --> left_bracket <expression> right_bracket | empty
<block statements> --> left_brace <statements> right_brace 
<statements> --> empty | <statement> <statements> 
<statement> --> ID <statement Z> | <if statement> | <while statement> | 
<return statement> | <break statement> | <continue statement> | read left_parenthesis  ID right_parenthesis semicolon | write left_parenthesis <expression> right_parenthesis semicolon | print left_parenthesis  STRING right_parenthesis semicolon 
<statement Z> --> <assignment Z> | <func call>
<assignment Z> --> equal_sign <expression> semicolon | left_bracket <expression> right_bracket equal_sign <expression> semicolon
<func call> --> left_parenthesis <expr list> right_parenthesis semicolon 
<expr list> --> empty | <non-empty expr list> 
<non-empty expr list> --> <expression> <non-empty expr list prime>
<non-empty expr list prime> --> comma <expression> <non-empty expr list prime> | empty
<if statement> --> if left_parenthesis <condition expression> right_parenthesis <block statements> 
<condition expression> -->  <condition> <condition expression Z>
<condition expression Z> --> <condition op> <condition> | empty
<condition op> --> double_end_sign | double_or_sign 
<condition> --> <expression> <comparison op> <expression> 
<comparison op> --> == | != | > | >= | < | <=
<while statement> --> while left_parenthesis <condition expression> right_parenthesis <block statements> 
<return statement> --> return <return statement Z>
<return statement Z> --> <expression> semicolon | semicolon 
<break statement> ---> break semicolon 
<continue statement> ---> continue semicolon
<expression> --> <term> <expression prime>
<expression prime> --> <addop> <term> <expression prime> | empty
<addop> --> plus_sign | minus_sign 
<term> --> <factor> <term prime>
<term prime> --> <mulop> <factor> <term prime> | empty
<mulop> --> star_sign | forward_slash 
<factor> --> ID <factor Z> | NUMBER | minus_sign NUMBER | left_parenthesis <expression>right_parenthesis 
<factor Z> --> left_bracket <expression> right_bracket | left_parenthesis <expr list> right_parenthesis | empty
